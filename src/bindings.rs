/* automatically generated by rust-bindgen */

pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _ARGMAX: u32 = 100;
pub const _CRT_INT_MAX: u32 = 2147483647;
pub const _CRT_FUNCTIONS_REQUIRED: u32 = 1;
pub const _CRT_HAS_CXX17: u32 = 0;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE: u32 = 1;
pub const _CRT_BUILD_DESKTOP_APP: u32 = 1;
pub const __STDC_SECURE_LIB__: f64 = 200411.0;
pub const __GOT_SECURE_LIB__: f64 = 200411.0;
pub const __STDC_WANT_SECURE_LIB__: u32 = 1;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 254;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const MESHOPTIMIZER_VERSION: u32 = 80;
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut va_list, ...);
}
pub type __vcrt_bool = bool;
pub type wchar_t = ::std::os::raw::c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize);
}
extern "C" {
    #[link_name = "\u{1}__security_cookie"]
    pub static mut __security_cookie: usize;
}
pub type __crt_bool = bool;
extern "C" {
    pub fn _invalid_parameter_noinfo();
}
extern "C" {
    pub fn _invalid_parameter_noinfo_noreturn();
}
extern "C" {
    pub fn _invoke_watson(
        _Expression: *const wchar_t,
        _FunctionName: *const wchar_t,
        _FileName: *const wchar_t,
        _LineNo: ::std::os::raw::c_uint,
        _Reserved: usize,
    );
}
pub type errno_t = ::std::os::raw::c_int;
pub type wint_t = ::std::os::raw::c_ushort;
pub type wctype_t = ::std::os::raw::c_ushort;
pub type __time32_t = ::std::os::raw::c_long;
pub type __time64_t = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data_public {
    pub _locale_pctype: *const ::std::os::raw::c_ushort,
    pub _locale_mb_cur_max: ::std::os::raw::c_int,
    pub _locale_lc_codepage: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_pointers {
    pub locinfo: *mut __crt_locale_data,
    pub mbcinfo: *mut __crt_multibyte_data,
}
pub type _locale_t = *mut __crt_locale_pointers;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Mbstatet {
    pub _Wchar: ::std::os::raw::c_ulong,
    pub _Byte: ::std::os::raw::c_ushort,
    pub _State: ::std::os::raw::c_ushort,
}
pub type mbstate_t = _Mbstatet;
pub type time_t = __time64_t;
pub type rsize_t = usize;
extern "C" {
    pub fn _wassert(_Message: *const wchar_t, _File: *const wchar_t, _Line: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn _errno() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_errno(_Value: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_errno(_Value: *mut ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn __threadid() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __threadhandle() -> usize;
}
extern "C" {
    /// Generates a vertex remap table from the vertex buffer and an optional index buffer and returns number of unique vertices
    /// As a result, all vertices that are binary equivalent map to the same (new) location, with no gaps in the resulting sequence.
    ///
    /// destination must contain enough space for the resulting remap table (vertex_count elements)
    /// indices can be NULL if the input is unindexed
    pub fn meshopt_generateVertexRemap(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertices: *const ::std::os::raw::c_void,
        vertex_count: usize,
        vertex_size: usize,
    ) -> usize;
}
extern "C" {
    /// Generates vertex buffer from the source vertex buffer and remap table generated by generateVertexRemap
    ///
    /// destination must contain enough space for the resulting vertex buffer (unique_vertex_count elements, returned by generateVertexRemap)
    /// vertex_count should be the initial vertex count and not the value returned by meshopt_generateVertexRemap()
    pub fn meshopt_remapVertexBuffer(
        destination: *mut ::std::os::raw::c_void,
        vertices: *const ::std::os::raw::c_void,
        vertex_count: usize,
        vertex_size: usize,
        remap: *const ::std::os::raw::c_uint,
    );
}
extern "C" {
    /// Generate index buffer from the source index buffer and remap table generated by generateVertexRemap
    ///
    /// destination must contain enough space for the resulting index buffer (index_count elements)
    /// indices can be NULL if the input is unindexed
    pub fn meshopt_remapIndexBuffer(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        remap: *const ::std::os::raw::c_uint,
    );
}
extern "C" {
    /// Vertex transform cache optimizer
    /// Reorders indices to reduce the number of GPU vertex shader invocations
    ///
    /// destination must contain enough space for the resulting index buffer (index_count elements)
    pub fn meshopt_optimizeVertexCache(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_count: usize,
    );
}
extern "C" {
    /// Vertex transform cache optimizer for FIFO caches
    /// Reorders indices to reduce the number of GPU vertex shader invocations
    /// Generally takes ~3x less time to optimize meshes but produces inferior results compared to meshopt_optimizeVertexCache
    ///
    /// destination must contain enough space for the resulting index buffer (index_count elements)
    /// cache_size should be less than the actual GPU cache size to avoid cache thrashing
    pub fn meshopt_optimizeVertexCacheFifo(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_count: usize,
        cache_size: ::std::os::raw::c_uint,
    );
}
extern "C" {
    /// Overdraw optimizer
    /// Reorders indices to reduce the number of GPU vertex shader invocations and the pixel overdraw
    ///
    /// destination must contain enough space for the resulting index buffer (index_count elements)
    /// indices must contain index data that is the result of optimizeVertexCache (*not* the original mesh indices!)
    /// vertex_positions should have float3 position in the first 12 bytes of each vertex - similar to glVertexPointer
    /// threshold indicates how much the overdraw optimizer can degrade vertex cache efficiency (1.05 = up to 5%) to reduce overdraw more efficiently
    pub fn meshopt_optimizeOverdraw(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_positions: *const f32,
        vertex_count: usize,
        vertex_positions_stride: usize,
        threshold: f32,
    );
}
extern "C" {
    /// Vertex fetch cache optimizer
    /// Generates vertex remap to reduce the amount of GPU memory fetches during vertex processing
    /// The resulting remap table should be used to reorder vertex/index buffers using meshopt_remapVertexBuffer/meshopt_remapIndexBuffer
    ///
    /// destination must contain enough space for the resulting remap table (vertex_count elements)
    pub fn meshopt_optimizeVertexFetchRemap(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_count: usize,
    ) -> usize;
}
extern "C" {
    /// Vertex fetch cache optimizer
    /// Reorders vertices and changes indices to reduce the amount of GPU memory fetches during vertex processing
    ///
    /// destination must contain enough space for the resulting vertex buffer (vertex_count elements)
    /// indices is used both as an input and as an output index buffer
    pub fn meshopt_optimizeVertexFetch(
        destination: *mut ::std::os::raw::c_void,
        indices: *mut ::std::os::raw::c_uint,
        index_count: usize,
        vertices: *const ::std::os::raw::c_void,
        vertex_count: usize,
        vertex_size: usize,
    ) -> usize;
}
extern "C" {
    /// Index buffer encoder
    /// Encodes index data into an array of bytes that is generally much smaller (<1.5 bytes/triangle) and compresses better (<1 bytes/triangle) compared to original.
    /// Returns encoded data size on success, 0 on error; the only error condition is if buffer doesn't have enough space
    /// For maximum efficiency the index buffer being encoded has to be optimized for vertex cache and vertex fetch first.
    ///
    /// buffer must contain enough space for the encoded index buffer (use meshopt_encodeIndexBufferBound to estimate)
    pub fn meshopt_encodeIndexBuffer(
        buffer: *mut ::std::os::raw::c_uchar,
        buffer_size: usize,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
    ) -> usize;
}
extern "C" {
    pub fn meshopt_encodeIndexBufferBound(index_count: usize, vertex_count: usize) -> usize;
}
extern "C" {
    /// Index buffer decoder
    /// Decodes index data from an array of bytes generated by meshopt_encodeIndexBuffer
    /// Returns 0 if decoding was successful, and an error code otherwise
    ///
    /// destination must contain enough space for the resulting index buffer (index_count elements)
    pub fn meshopt_decodeIndexBuffer(
        destination: *mut ::std::os::raw::c_void,
        index_count: usize,
        index_size: usize,
        buffer: *const ::std::os::raw::c_uchar,
        buffer_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Vertex buffer encoder
    /// Encodes vertex data into an array of bytes that is generally smaller and compresses better compared to original.
    /// Returns encoded data size on success, 0 on error
    ///
    /// buffer must contain enough space for the encoded vertex buffer (use meshopt_encodeVertexBufferBound to estimate)
    pub fn meshopt_encodeVertexBuffer(
        buffer: *mut ::std::os::raw::c_uchar,
        buffer_size: usize,
        vertices: *const ::std::os::raw::c_void,
        vertex_count: usize,
        vertex_size: usize,
    ) -> usize;
}
extern "C" {
    pub fn meshopt_encodeVertexBufferBound(vertex_count: usize, vertex_size: usize) -> usize;
}
extern "C" {
    /// Vertex buffer decoder
    /// Decodes vertex data from an array of bytes generated by meshopt_encodeVertexBuffer
    /// Returns 0 if decoding was successful, and an error code otherwise
    ///
    /// destination must contain enough space for the resulting vertex buffer (vertex_count * vertex_size bytes)
    pub fn meshopt_decodeVertexBuffer(
        destination: *mut ::std::os::raw::c_void,
        vertex_count: usize,
        vertex_size: usize,
        buffer: *const ::std::os::raw::c_uchar,
        buffer_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Experimental: Mesh simplifier
    /// Reduces the number of triangles in the mesh, attempting to preserve mesh appearance as much as possible
    /// Returns the number of indices after simplification, with destination containing new index data
    ///
    /// destination must contain enough space for the source index buffer (since optimization is iterative, this means index_count elements - *not* target_index_count!)
    /// vertex_positions should have float3 position in the first 12 bytes of each vertex - similar to glVertexPointer
    pub fn meshopt_simplify(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_positions: *const f32,
        vertex_count: usize,
        vertex_positions_stride: usize,
        target_index_count: usize,
        target_error: f32,
    ) -> usize;
}
extern "C" {
    /// Mesh stripifier
    /// Converts a previously vertex cache optimized triangle list to triangle strip, stitching strips using restart index
    /// Returns the number of indices in the resulting strip, with destination containing new index data
    /// For maximum efficiency the index buffer being converted has to be optimized for vertex cache first.
    ///
    /// destination must contain enough space for the worst case target index buffer (index_count / 3 * 4 elements)
    pub fn meshopt_stripify(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_count: usize,
    ) -> usize;
}
extern "C" {
    /// Mesh unstripifier
    /// Converts a triangle strip to a triangle list
    /// Returns the number of indices in the resulting list, with destination containing new index data
    ///
    /// destination must contain enough space for the worst case target index buffer ((index_count - 2) * 3 elements)
    pub fn meshopt_unstripify(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
    ) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct meshopt_VertexCacheStatistics {
    pub vertices_transformed: ::std::os::raw::c_uint,
    pub warps_executed: ::std::os::raw::c_uint,
    pub acmr: f32,
    pub atvr: f32,
}
extern "C" {
    /// Vertex transform cache analyzer
    /// Returns cache hit statistics using a simplified FIFO model
    /// Results may not match actual GPU performance
    pub fn meshopt_analyzeVertexCache(
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_count: usize,
        cache_size: ::std::os::raw::c_uint,
        warp_size: ::std::os::raw::c_uint,
        primgroup_size: ::std::os::raw::c_uint,
    ) -> meshopt_VertexCacheStatistics;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct meshopt_OverdrawStatistics {
    pub pixels_covered: ::std::os::raw::c_uint,
    pub pixels_shaded: ::std::os::raw::c_uint,
    pub overdraw: f32,
}
extern "C" {
    /// Overdraw analyzer
    /// Returns overdraw statistics using a software rasterizer
    /// Results may not match actual GPU performance
    ///
    /// vertex_positions should have float3 position in the first 12 bytes of each vertex - similar to glVertexPointer
    pub fn meshopt_analyzeOverdraw(
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_positions: *const f32,
        vertex_count: usize,
        vertex_positions_stride: usize,
    ) -> meshopt_OverdrawStatistics;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct meshopt_VertexFetchStatistics {
    pub bytes_fetched: ::std::os::raw::c_uint,
    pub overfetch: f32,
}
extern "C" {
    /// Vertex fetch cache analyzer
    /// Returns cache hit statistics using a simplified direct mapped model
    /// Results may not match actual GPU performance
    pub fn meshopt_analyzeVertexFetch(
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_count: usize,
        vertex_size: usize,
    ) -> meshopt_VertexFetchStatistics;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_multibyte_data {
    pub _address: u8,
}
